name: Deploy Backend to EC2

on:
  push:
    branches:
      - develop
    paths:
      - 'backend/**'
      - '.github/workflows/deploy-backend.yml'
  workflow_dispatch:
    inputs:
      branch:
        description: 'develop'
        required: true
        default: 'develop'
        type: choice
        options:
          - develop
          - main

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch || github.ref }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::034427362829:role/himelog_ec2_develop
          role-session-name: GitHubActions-DeployBackend
          aws-region: ap-northeast-1

      - name: Check EC2 instance status
        run: |
          INSTANCE_ID="i-0c78bb1a7c6be7fa9"
          
          echo "Checking EC2 instance status: $INSTANCE_ID"
          
          # ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å­˜åœ¨ã¨çŠ¶æ…‹ã‚’ç¢ºèª
          INSTANCE_INFO=$(aws ec2 describe-instances \
            --instance-ids "$INSTANCE_ID" \
            --query 'Reservations[0].Instances[0].[State.Name, IamInstanceProfile.Arn, Tags[?Key==`Name`].Value | [0]]' \
            --output text 2>&1) || {
            echo "Error: Failed to describe instance"
            echo "Output: $INSTANCE_INFO"
            echo ""
            echo "Possible issues:"
            echo "1. Instance ID is incorrect: $INSTANCE_ID"
            echo "2. Instance does not exist in this AWS account"
            echo "3. IAM role does not have ec2:DescribeInstances permission"
            exit 1
          }
          
          if [ -z "$INSTANCE_INFO" ] || [ "$INSTANCE_INFO" = "None" ]; then
            echo "Error: Instance not found: $INSTANCE_ID"
            echo "Please verify the instance ID is correct"
            exit 1
          fi
          
          INSTANCE_STATE=$(echo "$INSTANCE_INFO" | awk '{print $1}')
          IAM_PROFILE=$(echo "$INSTANCE_INFO" | awk '{print $2}')
          INSTANCE_NAME=$(echo "$INSTANCE_INFO" | awk '{print $3}')
          
          echo "Instance Name: $INSTANCE_NAME"
          echo "Instance State: $INSTANCE_STATE"
          echo "IAM Instance Profile: $IAM_PROFILE"
          
          if [ "$INSTANCE_STATE" != "running" ]; then
            echo "Error: Instance is not running (current state: $INSTANCE_STATE)"
            echo "SSM commands can only be sent to running instances"
            echo ""
            echo "Please start the instance first:"
            echo "  aws ec2 start-instances --instance-ids $INSTANCE_ID"
            exit 1
          fi
          
          # IAMãƒ­ãƒ¼ãƒ«ã®ç¢ºèª
          echo ""
          echo "Checking IAM role configuration..."
          if [ -z "$IAM_PROFILE" ] || [ "$IAM_PROFILE" = "None" ]; then
            echo "âŒ Error: No IAM instance profile attached to the instance"
            echo "SSM requires an IAM role with AmazonSSMManagedInstanceCore policy"
            echo ""
            echo "To fix this:"
            echo "1. Create an IAM role with AmazonSSMManagedInstanceCore managed policy"
            echo "2. Attach the IAM role to the EC2 instance:"
            echo "   aws ec2 associate-iam-instance-profile \\"
            echo "     --instance-id $INSTANCE_ID \\"
            echo "     --iam-instance-profile Name=your-instance-profile-name"
            exit 1
          fi
          
          # IAMãƒ­ãƒ¼ãƒ«åã‚’æŠ½å‡º
          IAM_ROLE_NAME=$(echo "$IAM_PROFILE" | awk -F'/' '{print $NF}')
          echo "IAM Role Name: $IAM_ROLE_NAME"
          
          # IAMãƒ­ãƒ¼ãƒ«ã®ãƒãƒªã‚·ãƒ¼ã‚’ç¢ºèªï¼ˆå¯èƒ½ãªå ´åˆï¼‰
          set +e
          IAM_POLICIES=$(aws iam list-attached-role-policies --role-name "$IAM_ROLE_NAME" --query 'AttachedPolicies[?PolicyArn==`arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore`]' --output text 2>&1)
          set -e
          
          if echo "$IAM_POLICIES" | grep -q "AmazonSSMManagedInstanceCore"; then
            echo "âœ… AmazonSSMManagedInstanceCore policy is attached"
          else
            echo "âš ï¸  Warning: AmazonSSMManagedInstanceCore policy may not be attached"
            echo "Please verify the IAM role has this managed policy attached"
            echo "You can check with:"
            echo "  aws iam list-attached-role-policies --role-name $IAM_ROLE_NAME"
          fi
          
          # SSMã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®çŠ¶æ…‹ã‚’ç¢ºèªï¼ˆå¿…é ˆãƒã‚§ãƒƒã‚¯ï¼‰
          echo ""
          echo "Checking SSM agent status..."
          set +e
          SSM_STATUS=$(aws ssm describe-instance-information \
            --filters "Key=InstanceIds,Values=$INSTANCE_ID" \
            --query 'InstanceInformationList[0].[PingStatus, LastPingDateTime, AgentVersion]' \
            --output text 2>&1)
          SSM_STATUS_EXIT_CODE=$?
          set -e
          
          if [ $SSM_STATUS_EXIT_CODE -ne 0 ]; then
            echo "âŒ Error: Could not check SSM agent status"
            echo "Output: $SSM_STATUS"
            echo ""
            echo "This error usually means:"
            echo "1. SSM agent is not installed on the instance"
            echo "2. Instance is not registered with SSM"
            echo "3. IAM role does not have ssm:DescribeInstanceInformation permission"
            echo ""
            echo "To fix this:"
            echo "1. Install SSM agent on the instance"
            echo "2. Attach an IAM role with AmazonSSMManagedInstanceCore policy to the instance"
            echo "3. Ensure SSM agent service is running: sudo systemctl start amazon-ssm-agent"
            echo "4. Wait a few minutes for the instance to register with SSM"
            exit 1
          fi
          
          if [ -z "$SSM_STATUS" ] || [ "$SSM_STATUS" = "None" ] || [ "$SSM_STATUS" = "None None None" ]; then
            echo "âŒ Error: SSM instance information not found"
            echo "The instance is not registered with AWS Systems Manager"
            echo ""
            echo "Based on the SSM agent logs you shared, the agent is running but cannot connect to Systems Manager"
            echo "This typically indicates:"
            echo ""
            echo "1. âŒ IAM Role Issue (Most Common):"
            echo "   - IAM role may not have AmazonSSMManagedInstanceCore policy"
            echo "   - Or IAM role is not attached to the instance"
            echo "   Check with: aws iam list-attached-role-policies --role-name $IAM_ROLE_NAME"
            echo ""
            echo "2. âŒ VPC Endpoints Not Configured:"
            echo "   - If instance is in VPC without internet gateway, VPC endpoints are required"
            echo "   - Required endpoints: ssm, ssmmessages, ec2messages"
            echo "   Check with: aws ec2 describe-vpc-endpoints"
            echo ""
            echo "3. âš ï¸  Security Group Rules:"
            echo "   - Security group must allow outbound HTTPS (443) traffic"
            echo ""
            echo "To diagnose on the instance, check SSM agent logs:"
            echo "  sudo tail -f /var/log/amazon/ssm/amazon-ssm-agent.log"
            echo ""
            echo "Common error in logs: 'status code: 400' means IAM permission issue"
            echo "Fix by ensuring IAM role has AmazonSSMManagedInstanceCore policy attached"
            exit 1
          fi
          
          SSM_PING_STATUS=$(echo "$SSM_STATUS" | awk '{print $1}')
          SSM_LAST_PING=$(echo "$SSM_STATUS" | awk '{print $2}')
          SSM_AGENT_VERSION=$(echo "$SSM_STATUS" | awk '{print $3}')
          
          echo "âœ… SSM Agent Version: $SSM_AGENT_VERSION"
          echo "âœ… SSM Ping Status: $SSM_PING_STATUS"
          echo "âœ… Last Ping: $SSM_LAST_PING"
          
          if [ "$SSM_PING_STATUS" != "Online" ]; then
            echo "âŒ Error: SSM agent is not online (status: $SSM_PING_STATUS)"
            echo "SSM commands cannot be sent to instances that are not online"
            echo ""
            echo "Please ensure:"
            echo "1. SSM agent service is running on the instance: sudo systemctl status amazon-ssm-agent"
            echo "2. Instance has an IAM role with AmazonSSMManagedInstanceCore policy attached"
            echo "3. Network connectivity is available (check security groups and VPC endpoints)"
            echo "4. Wait a few minutes after starting the agent for it to register"
            exit 1
          fi
          
          echo ""
          echo "âœ… All checks passed. Instance is ready for SSM commands."

      - name: Deploy via SSM - Git pull and deploy backend only
        id: deploy
        run: |
          set -e
          INSTANCE_ID="i-0c78bb1a7c6be7fa9"
          
          # ã™ã¹ã¦ã®ã‚³ãƒžãƒ³ãƒ‰ã‚’1ã¤ã®ã‚·ã‚§ãƒ«ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¨ã—ã¦çµåˆ
          # ã“ã‚Œã«ã‚ˆã‚Šã€ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªç§»å‹•ãªã©ã®çŠ¶æ…‹ãŒå¼•ãç¶™ãŒã‚Œã‚‹
          DEPLOY_SCRIPT='#!/bin/bash
          set -e
          export HOME=/root
          export COMPOSER_HOME=/root/.composer
          
          REPO_PATH=/mf/himelog-repo
          DEPLOY_PATH=/mf/himelog-api
          GITHUB_REPO=https://github.com/tadasuke/himelog.git
          BRANCH=develop
          
          echo "=== Starting deployment ==="
          echo "Current directory: $(pwd)"
          echo "Current user: $(whoami)"
          
          echo ""
          echo "Step 1: Updating repository"
          if [ -d "$REPO_PATH/.git" ]; then
            echo "Repository exists, pulling latest changes"
            cd "$REPO_PATH"
            git fetch origin || { echo "Error: git fetch failed" && exit 1; }
            git reset --hard origin/$BRANCH || { echo "Error: git reset failed" && exit 1; }
            git clean -fd || { echo "Error: git clean failed" && exit 1; }
          else
            echo "Repository does not exist, cloning"
            mkdir -p "$(dirname $REPO_PATH)"
            cd "$(dirname $REPO_PATH)"
            git clone -b $BRANCH "$GITHUB_REPO" "$(basename $REPO_PATH)" || { echo "Error: git clone failed" && exit 1; }
          fi
          
          echo ""
          echo "Step 2: Verifying repository structure"
          test -d "$REPO_PATH/backend" || { echo "Error: backend directory not found" && exit 1; }
          
          echo ""
          echo "Step 3: Syncing backend files to deployment path"
          mkdir -p "$DEPLOY_PATH" || { echo "Error: Failed to create deployment directory" && exit 1; }
          rsync -av --exclude=.git --exclude=node_modules --exclude=vendor --exclude="storage/logs/*.log" --exclude="storage/framework/cache/*" --exclude="storage/framework/sessions/*" --exclude="storage/framework/views/*" "$REPO_PATH/backend/" "$DEPLOY_PATH/" || { echo "Error: rsync failed" && exit 1; }
          
          echo ""
          echo "Step 4: Installing composer dependencies"
          cd "$DEPLOY_PATH" || { echo "Error: Failed to change to deployment directory" && exit 1; }
          # composer installã‚’è©¦è¡Œ
          set +e
          composer install --no-dev --optimize-autoloader --no-interaction
          COMPOSER_INSTALL_EXIT_CODE=$?
          set -e
          
          if [ $COMPOSER_INSTALL_EXIT_CODE -ne 0 ]; then
            echo "Warning: composer install failed (exit code: $COMPOSER_INSTALL_EXIT_CODE)"
            echo "This is likely due to composer.lock being out of date with composer.json"
            echo "Running composer update as fallback (not recommended for production)"
            echo "Please update composer.lock in your repository and commit it to avoid this"
            composer update --no-dev --optimize-autoloader --no-interaction || { echo "Error: composer update failed" && exit 1; }
          fi
          
          echo ""
          echo "Step 5: Verifying PHP and artisan availability"
          php --version || { echo "Error: PHP is not available" && exit 1; }
          test -f artisan || { echo "Error: artisan file not found in $(pwd)" && exit 1; }
          
          echo ""
          echo "Step 6: Clearing Laravel caches"
          php artisan config:clear || { echo "Error: config:clear failed" && exit 1; }
          # cache:clearã¯ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æŽ¥ç¶šãŒå¿…è¦ãªå ´åˆãŒã‚ã‚‹ãŸã‚ã€ã‚¨ãƒ©ãƒ¼ã‚’ç„¡è¦–ã—ã¦ç¶šè¡Œ
          set +e
          php artisan cache:clear
          CACHE_CLEAR_EXIT_CODE=$?
          set -e
          if [ $CACHE_CLEAR_EXIT_CODE -ne 0 ]; then
            echo "Warning: cache:clear failed (exit code: $CACHE_CLEAR_EXIT_CODE)"
            echo "This may be due to database connection not being available yet, continuing..."
          fi
          php artisan route:clear || { echo "Error: route:clear failed" && exit 1; }
          # view:clearã¯ãƒ“ãƒ¥ãƒ¼ãƒ‘ã‚¹ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã«å¤±æ•—ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€ã‚¨ãƒ©ãƒ¼ã‚’ç„¡è¦–ã—ã¦ç¶šè¡Œ
          set +e
          php artisan view:clear
          VIEW_CLEAR_EXIT_CODE=$?
          set -e
          if [ $VIEW_CLEAR_EXIT_CODE -ne 0 ]; then
            echo "Warning: view:clear failed (exit code: $VIEW_CLEAR_EXIT_CODE)"
            echo "This may be due to view path not being found, continuing..."
          fi
          
          echo ""
          echo "Step 7: Caching configuration (this will fetch DB credentials from Secrets Manager)"
          # AWS_SECRET_ARNãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
          if [ -z "$AWS_SECRET_ARN" ]; then
            echo "Warning: AWS_SECRET_ARN is not set in environment variables"
            echo "Checking .env file..."
            if [ -f "$DEPLOY_PATH/.env" ]; then
              AWS_SECRET_ARN_FROM_ENV=$(grep "^AWS_SECRET_ARN=" "$DEPLOY_PATH/.env" | cut -d '=' -f2 | tr -d '"' | tr -d "'" || echo "")
              if [ -n "$AWS_SECRET_ARN_FROM_ENV" ]; then
                echo "Found AWS_SECRET_ARN in .env file"
                export AWS_SECRET_ARN="$AWS_SECRET_ARN_FROM_ENV"
              else
                echo "Warning: AWS_SECRET_ARN not found in .env file"
              fi
            else
              echo "Warning: .env file not found at $DEPLOY_PATH/.env"
            fi
          else
            echo "AWS_SECRET_ARN is set: $AWS_SECRET_ARN"
          fi
          # config:cacheã‚’å®Ÿè¡Œã™ã‚‹ã¨ã€ConfigCacheServiceProviderãŒSecrets Managerã‹ã‚‰DBæŽ¥ç¶šæƒ…å ±ã‚’å–å¾—ã—ã¦ç’°å¢ƒå¤‰æ•°ã«è¨­å®šã™ã‚‹
          php artisan config:cache || { echo "Error: config:cache failed" && exit 1; }
          
          echo ""
          echo "Step 8: Running migrations"
          # migrateã¯ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æŽ¥ç¶šãŒå¿…è¦ï¼ˆconfig:cacheã§Secrets Managerã‹ã‚‰å–å¾—ã—ãŸæƒ…å ±ã‚’ä½¿ç”¨ï¼‰
          set +e
          php artisan migrate --force
          MIGRATE_EXIT_CODE=$?
          set -e
          
          if [ $MIGRATE_EXIT_CODE -ne 0 ]; then
            echo "Warning: migrate failed (exit code: $MIGRATE_EXIT_CODE)"
            echo "This is likely due to database connection issues:"
            echo "1. Database server may not be running or accessible"
            echo "2. AWS_SECRET_ARN may not be set correctly"
            echo "3. Secrets Manager may not be accessible from EC2 instance"
            echo "4. Network/Security group may not allow connection"
            echo "Continuing deployment, but migrations were not applied"
            echo "Please check database connection and run migrations manually if needed"
          else
            echo "Migrations completed successfully"
          fi
          
          echo ""
          echo "Step 9: Optimizing Laravel (caching routes and views)"
          php artisan route:cache || { echo "Error: route:cache failed" && exit 1; }
          php artisan view:cache || { echo "Error: view:cache failed" && exit 1; }
          
          echo ""
          echo "=== Deployment completed successfully ==="'
          
          # JSONãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆ
          # jqã¾ãŸã¯python3ã‚’ä½¿ç”¨ã—ã¦JSONã‚’ç”Ÿæˆ
          if command -v jq > /dev/null 2>&1; then
            # jqã‚’ä½¿ç”¨ï¼ˆæŽ¨å¥¨ï¼‰
            echo "$DEPLOY_SCRIPT" | jq -Rs '{commands: [.]}' > /tmp/ssm-params.json
          elif command -v python3 > /dev/null 2>&1; then
            # python3ã‚’ä½¿ç”¨ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
            echo "$DEPLOY_SCRIPT" | python3 -c "import json, sys; print(json.dumps({'commands': [sys.stdin.read()]}))" > /tmp/ssm-params.json
          else
            echo "Error: Neither jq nor python3 is available"
            exit 1
          fi
          
          echo "Generated SSM parameters file:"
          cat /tmp/ssm-params.json
          
          echo "Sending SSM command to instance: $INSTANCE_ID"
          echo "Parameters file contents:"
          cat /tmp/ssm-params.json
          
          # SSMã‚³ãƒžãƒ³ãƒ‰ã‚’å®Ÿè¡Œï¼ˆstderrã¨stdoutã‚’åˆ†é›¢ï¼‰
          set +e
          COMMAND_OUTPUT=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters file:///tmp/ssm-params.json \
            --cloud-watch-output-config 'CloudWatchOutputEnabled=true' \
            --query 'Command.CommandId' \
            --output text 2>&1)
          EXIT_CODE=$?
          set -e
          
          if [ $EXIT_CODE -ne 0 ]; then
            echo "âŒ Error sending SSM command (exit code: $EXIT_CODE)"
            echo "Command output:"
            echo "$COMMAND_OUTPUT"
            echo ""
            echo "ðŸ” Troubleshooting steps:"
            echo "1. Verify instance ID is correct: $INSTANCE_ID"
            echo "2. Check instance is running: aws ec2 describe-instances --instance-ids $INSTANCE_ID"
            echo "3. Verify SSM agent is online: aws ssm describe-instance-information --filters Key=InstanceIds,Values=$INSTANCE_ID"
            echo "4. Check IAM role has SSM permissions attached to the instance"
            echo "5. Verify VPC endpoints are configured (if instance is in VPC)"
            echo ""
            echo "Full error response:"
            aws ssm send-command \
              --instance-ids "$INSTANCE_ID" \
              --document-name "AWS-RunShellScript" \
              --parameters file:///tmp/ssm-params.json \
              --cloud-watch-output-config 'CloudWatchOutputEnabled=true' \
              --output json 2>&1 || true
            exit 1
          fi
          
          COMMAND_ID=$(echo "$COMMAND_OUTPUT" | tr -d '\n\r' | grep -o '^[a-f0-9-]*$' || echo "")
          
          if [ -z "$COMMAND_ID" ] || [ "$COMMAND_ID" = "None" ]; then
            echo "Error: Command ID is empty or None"
            echo "Raw output was: $COMMAND_OUTPUT"
            # ãƒ‡ãƒãƒƒã‚°ç”¨ã«ãƒ•ãƒ«ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’å–å¾—
            echo "Full response:"
            aws ssm send-command \
              --instance-ids "$INSTANCE_ID" \
              --document-name "AWS-RunShellScript" \
              --parameters file:///tmp/ssm-params.json \
              --cloud-watch-output-config 'CloudWatchOutputEnabled=true' \
              --output json || true
            exit 1
          fi
          
          # ç’°å¢ƒå¤‰æ•°ã¨å‡ºåŠ›ã®ä¸¡æ–¹ã«è¨­å®šï¼ˆä¸¡æ–¹ã®æ–¹æ³•ã§ç¢ºå®Ÿã«å—ã‘æ¸¡ã—ï¼‰
          echo "command_id=$COMMAND_ID" >> $GITHUB_ENV
          echo "Command sent successfully: $COMMAND_ID"
          echo "command_id=$COMMAND_ID" >> $GITHUB_OUTPUT

      - name: Wait for command completion
        run: |
          INSTANCE_ID="i-0c78bb1a7c6be7fa9"
          # ç’°å¢ƒå¤‰æ•°ã‹ã‚‰å–å¾—ï¼ˆsteps.outputsã¨envã®ä¸¡æ–¹ã‹ã‚‰è©¦ã™ï¼‰
          COMMAND_ID="${{ env.command_id }}"
          
          # ç’°å¢ƒå¤‰æ•°ãŒç©ºã®å ´åˆã¯steps.outputsã‹ã‚‰å–å¾—ã‚’è©¦ã¿ã‚‹
          if [ -z "$COMMAND_ID" ]; then
            COMMAND_ID="${{ steps.deploy.outputs.command_id }}"
          fi
          
          if [ -z "$COMMAND_ID" ]; then
            echo "Error: COMMAND_ID is not set"
            echo "Tried env.command_id: ${{ env.command_id }}"
            echo "Tried steps.deploy.outputs.command_id: ${{ steps.deploy.outputs.command_id }}"
            echo "Available environment variables:"
            env | grep -i command || true
            exit 1
          fi
          
          echo "Waiting for command to complete: $COMMAND_ID"
          echo "Instance ID: $INSTANCE_ID"
          MAX_WAIT_TIME=600  # 10åˆ†
          ELAPSED_TIME=0
          
          while true; do
            # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å–å¾—ï¼ˆã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’æ”¹å–„ï¼‰
            set +e
            STATUS_OUTPUT=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query 'Status' \
              --output text 2>&1)
            STATUS_EXIT_CODE=$?
            set -e
            
            if [ $STATUS_EXIT_CODE -ne 0 ]; then
              echo "Error getting command status (exit code: $STATUS_EXIT_CODE):"
              echo "$STATUS_OUTPUT"
              echo "Waiting 5 seconds before retry..."
              sleep 5
              ELAPSED_TIME=$((ELAPSED_TIME + 5))
              
              # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãƒã‚§ãƒƒã‚¯
              if [ $ELAPSED_TIME -ge $MAX_WAIT_TIME ]; then
                echo "Error: Timed out waiting for command status"
                exit 1
              fi
              continue
            fi
            
            STATUS=$(echo "$STATUS_OUTPUT" | tr -d '\n\r')
            echo "Command status: $STATUS (elapsed: ${ELAPSED_TIME}s)"
            
            if [ "$STATUS" = "Success" ]; then
              echo "Command completed successfully"
              break
            elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
              echo "Command failed with status: $STATUS"
              echo "Fetching command output..."
              # ã‚¨ãƒ©ãƒ¼å‡ºåŠ›ã‚‚è¡¨ç¤º
              set +e
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query '[StandardOutputContent, StandardErrorContent]' \
                --output text 2>&1 || true
              set -e
              exit 1
            fi
            
            # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãƒã‚§ãƒƒã‚¯
            if [ $ELAPSED_TIME -ge $MAX_WAIT_TIME ]; then
              echo "Error: Command timed out after ${MAX_WAIT_TIME}s"
              echo "Last status: $STATUS"
              exit 1
            fi
            
            sleep 5
            ELAPSED_TIME=$((ELAPSED_TIME + 5))
          done

      - name: Show command output
        continue-on-error: true
        run: |
          INSTANCE_ID="i-0c78bb1a7c6be7fa9"
          # ç’°å¢ƒå¤‰æ•°ã‹ã‚‰å–å¾—ï¼ˆsteps.outputsã¨envã®ä¸¡æ–¹ã‹ã‚‰è©¦ã™ï¼‰
          COMMAND_ID="${{ env.command_id }}"
          
          # ç’°å¢ƒå¤‰æ•°ãŒç©ºã®å ´åˆã¯steps.outputsã‹ã‚‰å–å¾—ã‚’è©¦ã¿ã‚‹
          if [ -z "$COMMAND_ID" ]; then
            COMMAND_ID="${{ steps.deploy.outputs.command_id }}"
          fi
          
          if [ -z "$COMMAND_ID" ]; then
            echo "Warning: COMMAND_ID is not set, skipping output display"
            exit 0
          fi
          
          echo "=== Command Output (Standard Output) ==="
          set +e
          STDOUT=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --query 'StandardOutputContent' \
            --output text 2>&1)
          STDOUT_EXIT_CODE=$?
          set -e
          
          if [ $STDOUT_EXIT_CODE -eq 0 ]; then
            echo "$STDOUT"
          else
            echo "Warning: Failed to get standard output (exit code: $STDOUT_EXIT_CODE)"
          fi
          
          echo ""
          echo "=== Command Output (Standard Error) ==="
          set +e
          STDERR=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --query 'StandardErrorContent' \
            --output text 2>&1)
          STDERR_EXIT_CODE=$?
          set -e
          
          if [ $STDERR_EXIT_CODE -eq 0 ]; then
            if [ -n "$STDERR" ] && [ "$STDERR" != "None" ]; then
              echo "$STDERR"
            else
              echo "(No error output)"
            fi
          else
            echo "Warning: Failed to get standard error (exit code: $STDERR_EXIT_CODE)"
          fi
          
          echo ""
          echo "=== Command Status ==="
          set +e
          STATUS=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --query 'Status' \
            --output text 2>&1)
          STATUS_EXIT_CODE=$?
          set -e
          
          if [ $STATUS_EXIT_CODE -eq 0 ]; then
            echo "Status: $STATUS"
          else
            echo "Warning: Failed to get command status (exit code: $STATUS_EXIT_CODE)"
          fi


name: Backend CI/CD

on:
  push:
    branches: [main, develop]
    paths:
      - 'backend/**'
      - '.github/workflows/backend.yml'
  pull_request:
    branches: [main, develop]
    paths:
      - 'backend/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment'
        required: true
        default: 'develop'
        type: choice
        options:
          - production
          - develop

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'push' && 
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch || github.ref }}

      - name: Determine environment
        id: env
        run: |
          if [ "${{ github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'production' || 'develop') }}" == "production" ]; then
            echo "env=production" >> $GITHUB_OUTPUT
            PRODUCTION_INSTANCE_ID="${{ secrets.PRODUCTION_EC2_INSTANCE_ID }}"
            if [ -z "$PRODUCTION_INSTANCE_ID" ]; then
              echo "Error: PRODUCTION_EC2_INSTANCE_ID is not set in GitHub Secrets" >&2
              exit 1
            fi
            echo "instance_id=$PRODUCTION_INSTANCE_ID" >> $GITHUB_OUTPUT
            echo "aws_role=arn:aws:iam::034427362829:role/himelog_ec2_production" >> $GITHUB_OUTPUT
            echo "branch=main" >> $GITHUB_OUTPUT
          else
            echo "env=develop" >> $GITHUB_OUTPUT
            DEVELOP_INSTANCE_ID="${{ secrets.DEVELOP_EC2_INSTANCE_ID }}"
            if [ -z "$DEVELOP_INSTANCE_ID" ]; then
              echo "Error: DEVELOP_EC2_INSTANCE_ID is not set in GitHub Secrets" >&2
              exit 1
            fi
            echo "instance_id=$DEVELOP_INSTANCE_ID" >> $GITHUB_OUTPUT
            echo "aws_role=arn:aws:iam::034427362829:role/himelog_ec2_develop" >> $GITHUB_OUTPUT
            echo "branch=develop" >> $GITHUB_OUTPUT
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.env.outputs.aws_role }}
          role-session-name: GitHubActions-BackendDeploy
          aws-region: ap-northeast-1

      - name: Check EC2 instance status
        run: |
          INSTANCE_ID="${{ steps.env.outputs.instance_id }}"
          
          echo "Checking EC2 instance status: $INSTANCE_ID"
          
          # インスタンスの存在と状態を確認
          INSTANCE_INFO=$(aws ec2 describe-instances \
            --instance-ids "$INSTANCE_ID" \
            --query 'Reservations[0].Instances[0].[State.Name, IamInstanceProfile.Arn, Tags[?Key==`Name`].Value | [0]]' \
            --output text 2>&1) || {
            echo "Error: Failed to describe instance"
            echo "Output: $INSTANCE_INFO"
            exit 1
          }
          
          if [ -z "$INSTANCE_INFO" ] || [ "$INSTANCE_INFO" = "None" ]; then
            echo "Error: Instance not found: $INSTANCE_ID"
            exit 1
          fi
          
          INSTANCE_STATE=$(echo "$INSTANCE_INFO" | awk '{print $1}')
          IAM_PROFILE=$(echo "$INSTANCE_INFO" | awk '{print $2}')
          INSTANCE_NAME=$(echo "$INSTANCE_INFO" | awk '{print $3}')
          
          echo "Instance Name: $INSTANCE_NAME"
          echo "Instance State: $INSTANCE_STATE"
          
          if [ "$INSTANCE_STATE" != "running" ]; then
            echo "Error: Instance is not running (current state: $INSTANCE_STATE)"
            exit 1
          fi
          
          # SSMエージェントの状態を確認
          set +e
          SSM_STATUS=$(aws ssm describe-instance-information \
            --filters "Key=InstanceIds,Values=$INSTANCE_ID" \
            --query 'InstanceInformationList[0].[PingStatus, LastPingDateTime, AgentVersion]' \
            --output text 2>&1)
          SSM_STATUS_EXIT_CODE=$?
          set -e
          
          if [ $SSM_STATUS_EXIT_CODE -ne 0 ] || [ -z "$SSM_STATUS" ] || [ "$SSM_STATUS" = "None" ]; then
            echo "Error: SSM agent is not available or instance is not registered"
            exit 1
          fi
          
          SSM_PING_STATUS=$(echo "$SSM_STATUS" | awk '{print $1}')
          echo "SSM Ping Status: $SSM_PING_STATUS"
          
          if [ "$SSM_PING_STATUS" != "Online" ]; then
            echo "Error: SSM agent is not online (status: $SSM_PING_STATUS)"
            exit 1
          fi
          
          echo "✅ All checks passed. Instance is ready for SSM commands."

      - name: Deploy via SSM - Git pull and deploy backend
        id: deploy
        run: |
          set -e
          INSTANCE_ID="${{ steps.env.outputs.instance_id }}"
          BRANCH="${{ steps.env.outputs.branch }}"
          GITHUB_REPO="https://github.com/tadasuke/himelog.git"
          
          # デプロイスクリプト
          DEPLOY_SCRIPT='#!/bin/bash
          set -e
          export HOME=/root
          export COMPOSER_HOME=/root/.composer
          
          REPO_PATH=/mf/himelog-repo
          DEPLOY_PATH=/mf/himelog-api
          GITHUB_REPO='"$GITHUB_REPO"'
          BRANCH='"$BRANCH"'
          
          echo "=== Starting deployment ==="
          echo "Current directory: $(pwd)"
          echo "Current user: $(whoami)"
          
          echo ""
          echo "Step 1: Updating repository"
          if [ -d "$REPO_PATH/.git" ]; then
            echo "Repository exists, pulling latest changes"
            cd "$REPO_PATH"
            git fetch origin || { echo "Error: git fetch failed" && exit 1; }
            git reset --hard origin/$BRANCH || { echo "Error: git reset failed" && exit 1; }
            git clean -fd || { echo "Error: git clean failed" && exit 1; }
          else
            echo "Repository does not exist, cloning"
            mkdir -p "$(dirname $REPO_PATH)"
            cd "$(dirname $REPO_PATH)"
            git clone -b $BRANCH "$GITHUB_REPO" "$(basename $REPO_PATH)" || { echo "Error: git clone failed" && exit 1; }
          fi
          
          echo ""
          echo "Step 2: Verifying repository structure"
          test -d "$REPO_PATH/backend" || { echo "Error: backend directory not found" && exit 1; }
          
          echo ""
          echo "Step 3: Syncing backend files to deployment path"
          mkdir -p "$DEPLOY_PATH" || { echo "Error: Failed to create deployment directory" && exit 1; }
          rsync -av --exclude=.git --exclude=node_modules --exclude=vendor --exclude="storage/logs/*.log" --exclude="storage/framework/cache/*" --exclude="storage/framework/sessions/*" --exclude="storage/framework/views/*" "$REPO_PATH/backend/" "$DEPLOY_PATH/" || { echo "Error: rsync failed" && exit 1; }
          
          echo ""
          echo "Step 4: Installing composer dependencies"
          cd "$DEPLOY_PATH" || { echo "Error: Failed to change to deployment directory" && exit 1; }
          set +e
          composer install --no-dev --optimize-autoloader --no-interaction
          COMPOSER_INSTALL_EXIT_CODE=$?
          set -e
          
          if [ $COMPOSER_INSTALL_EXIT_CODE -ne 0 ]; then
            echo "Warning: composer install failed (exit code: $COMPOSER_INSTALL_EXIT_CODE)"
            echo "Running composer update as fallback"
            composer update --no-dev --optimize-autoloader --no-interaction || { echo "Error: composer update failed" && exit 1; }
          fi
          
          echo ""
          echo "Step 5: Verifying PHP and artisan availability"
          php --version || { echo "Error: PHP is not available" && exit 1; }
          test -f artisan || { echo "Error: artisan file not found in $(pwd)" && exit 1; }
          
          echo ""
          echo "Step 6: Clearing Laravel caches"
          php artisan config:clear || { echo "Error: config:clear failed" && exit 1; }
          set +e
          php artisan cache:clear
          set -e
          php artisan route:clear || { echo "Error: route:clear failed" && exit 1; }
          set +e
          php artisan view:clear
          set -e
          
          echo ""
          echo "Step 7: Caching configuration (this will fetch DB credentials from Secrets Manager)"
          # AWS_SECRET_ARNが設定されているか確認
          if [ -z "$AWS_SECRET_ARN" ]; then
            echo "Warning: AWS_SECRET_ARN is not set in environment variables"
            echo "Checking .env file..."
            if [ -f "$DEPLOY_PATH/.env" ]; then
              AWS_SECRET_ARN_FROM_ENV=$(grep "^AWS_SECRET_ARN=" "$DEPLOY_PATH/.env" | cut -d '=' -f2- || echo "")
              if [ -n "$AWS_SECRET_ARN_FROM_ENV" ]; then
                echo "Found AWS_SECRET_ARN in .env file"
                export AWS_SECRET_ARN="$AWS_SECRET_ARN_FROM_ENV"
              else
                echo "Warning: AWS_SECRET_ARN not found in .env file"
              fi
            else
              echo "Warning: .env file not found at $DEPLOY_PATH/.env"
            fi
          else
            echo "AWS_SECRET_ARN is set: $AWS_SECRET_ARN"
          fi
          # config:cacheを実行すると、ConfigCacheServiceProviderがSecrets ManagerからDB接続情報を取得して環境変数に設定する
          php artisan config:cache || { echo "Error: config:cache failed" && exit 1; }
          
          echo ""
          echo "Step 8: Running migrations"
          set +e
          php artisan migrate --force
          MIGRATE_EXIT_CODE=$?
          set -e
          
          if [ $MIGRATE_EXIT_CODE -ne 0 ]; then
            echo "Warning: migrate failed (exit code: $MIGRATE_EXIT_CODE)"
            echo "This is likely due to database connection issues:"
            echo "1. Database server may not be running or accessible"
            echo "2. AWS_SECRET_ARN may not be set correctly"
            echo "3. Secrets Manager may not be accessible from EC2 instance"
            echo "4. Network/Security group may not allow connection"
            echo "Continuing deployment, but migrations were not applied"
            echo "Please check database connection and run migrations manually if needed"
          else
            echo "Migrations completed successfully"
          fi
          
          echo ""
          echo "Step 9: Optimizing Laravel"
          php artisan route:cache || { echo "Error: route:cache failed" && exit 1; }
          set +e
          php artisan view:cache
          VIEW_CACHE_EXIT_CODE=$?
          set -e
          if [ $VIEW_CACHE_EXIT_CODE -ne 0 ]; then
            echo "Warning: view:cache failed (exit code: $VIEW_CACHE_EXIT_CODE)"
            echo "This may be due to view path not being found, continuing..."
          else
            echo "View cache created successfully"
          fi
          
          echo ""
          echo "=== Deployment completed successfully ==="'
          
          # JSONパラメータファイルを作成
          if command -v jq > /dev/null 2>&1; then
            echo "$DEPLOY_SCRIPT" | jq -Rs '{commands: [.]}' > /tmp/ssm-params.json
          elif command -v python3 > /dev/null 2>&1; then
            echo "$DEPLOY_SCRIPT" | python3 -c "import json, sys; print(json.dumps({'commands': [sys.stdin.read()]}))" > /tmp/ssm-params.json
          else
            echo "Error: Neither jq nor python3 is available"
            exit 1
          fi
          
          echo "Sending SSM command to instance: $INSTANCE_ID"
          
          # SSMコマンドを実行
          set +e
          COMMAND_OUTPUT=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters file:///tmp/ssm-params.json \
            --cloud-watch-output-config 'CloudWatchOutputEnabled=true' \
            --query 'Command.CommandId' \
            --output text 2>&1)
          EXIT_CODE=$?
          set -e
          
          if [ $EXIT_CODE -ne 0 ]; then
            echo "❌ Error sending SSM command (exit code: $EXIT_CODE)"
            echo "$COMMAND_OUTPUT"
            exit 1
          fi
          
          COMMAND_ID=$(echo "$COMMAND_OUTPUT" | tr -d '\n\r' | grep -o '^[a-f0-9-]*$' || echo "")
          
          if [ -z "$COMMAND_ID" ] || [ "$COMMAND_ID" = "None" ]; then
            echo "Error: Command ID is empty or None"
            echo "Raw output was: $COMMAND_OUTPUT"
            exit 1
          fi
          
          echo "command_id=$COMMAND_ID" >> $GITHUB_ENV
          echo "Command sent successfully: $COMMAND_ID"
          echo "command_id=$COMMAND_ID" >> $GITHUB_OUTPUT

      - name: Wait for command completion
        run: |
          INSTANCE_ID="${{ steps.env.outputs.instance_id }}"
          COMMAND_ID="${{ env.command_id }}"
          
          if [ -z "$COMMAND_ID" ]; then
            COMMAND_ID="${{ steps.deploy.outputs.command_id }}"
          fi
          
          if [ -z "$COMMAND_ID" ]; then
            echo "Error: COMMAND_ID is not set"
            exit 1
          fi
          
          echo "Waiting for command to complete: $COMMAND_ID"
          MAX_WAIT_TIME=600
          ELAPSED_TIME=0
          
          while true; do
            set +e
            STATUS_OUTPUT=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query 'Status' \
              --output text 2>&1)
            STATUS_EXIT_CODE=$?
            set -e
            
            if [ $STATUS_EXIT_CODE -ne 0 ]; then
              echo "Error getting command status, retrying..."
              sleep 5
              ELAPSED_TIME=$((ELAPSED_TIME + 5))
              if [ $ELAPSED_TIME -ge $MAX_WAIT_TIME ]; then
                echo "Error: Timed out waiting for command status"
                exit 1
              fi
              continue
            fi
            
            STATUS=$(echo "$STATUS_OUTPUT" | tr -d '\n\r')
            echo "Command status: $STATUS (elapsed: ${ELAPSED_TIME}s)"
            
            if [ "$STATUS" = "Success" ]; then
              echo "Command completed successfully"
              break
            elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
              echo "Command failed with status: $STATUS"
              exit 1
            fi
            
            if [ $ELAPSED_TIME -ge $MAX_WAIT_TIME ]; then
              echo "Error: Command timed out after ${MAX_WAIT_TIME}s"
              exit 1
            fi
            
            sleep 5
            ELAPSED_TIME=$((ELAPSED_TIME + 5))
          done

      - name: Show command output
        continue-on-error: true
        run: |
          INSTANCE_ID="${{ steps.env.outputs.instance_id }}"
          COMMAND_ID="${{ env.command_id }}"
          
          if [ -z "$COMMAND_ID" ]; then
            COMMAND_ID="${{ steps.deploy.outputs.command_id }}"
          fi
          
          if [ -z "$COMMAND_ID" ]; then
            echo "Warning: COMMAND_ID is not set, skipping output display"
            exit 0
          fi
          
          echo "=== Command Output ==="
          set +e
          aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --query 'StandardOutputContent' \
            --output text 2>&1
          set -e

